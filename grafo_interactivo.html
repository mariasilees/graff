<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafo Interactivo - Red Social</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: white; }
        h1 { text-align: center; color: #333; margin-bottom: 10px; }
        .container { max-width: 1400px; margin: 0 auto; position: relative; }
        #graph { border: 2px solid #333; border-radius: 8px; background: white; }
        .node { cursor: pointer; stroke: white; stroke-width: 2px; }
        .supernode { cursor: pointer; stroke: white; stroke-width: 3px; }
        .node.highlighted { stroke: #f39c12; stroke-width: 5px; }
        .link { stroke: #888; stroke-opacity: 0.6; stroke-width: 2px; }
        .link.added { stroke: #9b59b6; stroke-width: 3px; stroke-dasharray: 5,5; stroke-opacity: 0.7; }
        .link.perturbed { stroke: #e74c3c; stroke-width: 3px; stroke-dasharray: 3,3; stroke-opacity: 0.7; }
        .link.removed { stroke: #95a5a6; stroke-width: 1px; stroke-dasharray: 2,2; stroke-opacity: 0.3; }
        .node-label { font-size: 10px; font-weight: bold; text-anchor: middle; pointer-events: none; fill: white; }
        .supernode-label { font-size: 14px; font-weight: bold; text-anchor: middle; pointer-events: none; fill: white; }
        .cluster-label { font-size: 16px; font-weight: bold; text-anchor: middle; pointer-events: none; opacity: 0; transition: opacity 0.5s; }
        .tooltip { position: fixed; padding: 12px; background: yellow; border: 2px solid orange; border-radius: 8px; pointer-events: none; opacity: 0; font-size: 11px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 2000; max-width: 400px; }
        .warning-box { background: rgba(231, 76, 60, 0.9); border: 3px solid darkred; border-radius: 10px; padding: 15px; margin: 20px auto; width: 850px; font-size: 12px; font-weight: bold; transition: all 0.5s; }
        .metric-row { display: flex; align-items: center; margin: 8px 0; gap: 15px; }
        .metric-btn { padding: 8px 15px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; min-width: 160px; font-size: 12px; }
        .metric-btn:hover { opacity: 0.8; }
        .metric-result { flex: 1; background: rgba(255,255,255,0.2); padding: 8px 12px; border-radius: 5px; font-size: 11px; min-height: 20px; border-left: 3px solid #3498db; }
        .btn-degree { background: #3498db; }
        .btn-clustering { background: #2ecc71; }
        .result-clustering { border-left-color: #2ecc71; }
        .btn-centrality { background: #e67e22; }
        .result-centrality { border-left-color: #e67e22; }
        .btn-perturb { background: #e74c3c; border: 2px solid #c0392b; padding: 10px 20px; font-size: 14px; margin-top: 10px; }
        .btn-compare { background: #9b59b6; border: 2px solid #8e44ad; padding: 10px 20px; font-size: 14px; margin-top: 10px; }
        .warning-box.protected { background: rgba(46, 204, 113, 0.9); border: 3px solid green; }
        .warning-box.kanon { background: rgba(155, 89, 182, 0.9); border: 3px solid #8e44ad; }
        .warning-box.automorph { background: rgba(231, 76, 60, 0.9); border: 3px solid #c0392b; }
        .warning-box.anonymous { background: rgba(52, 152, 219, 0.9); border: 3px solid #2980b9; }
        .warning-box h3 { margin: 0 0 10px 0; color: #c0392b; font-size: 14px; }
        .warning-box.protected h3 { color: #27ae60; }
        .warning-box.kanon h3 { color: #8e44ad; }
        .warning-box.automorph h3 { color: #c0392b; }
        .warning-box.anonymous h3 { color: #2980b9; }
        .controls { text-align: center; margin: 15px 0; }
        button { padding: 10px 20px; margin: 0 5px; font-size: 14px; font-weight: bold; border: 2px solid #3498db; background: #3498db; color: white; border-radius: 5px; cursor: pointer; transition: background 0.3s; }
        button:hover { background: #2980b9; }
        button.active { background: #27ae60; border-color: #27ae60; }
        button.kanon-btn { border-color: #9b59b6; background: #9b59b6; }
        button.kanon-btn:hover { background: #8e44ad; }
        button.automorph-btn { border-color: #e74c3c; background: #e74c3c; }
        button.automorph-btn:hover { background: #c0392b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>GRAFO INTERACTIVO: Red Social de 30 Personas</h1>
        <div class="warning-box" id="warningBox">
            <h3 id="warningTitle">âš ï¸ RIESGO DE PRIVACIDAD</h3>
            <span id="warningText">
                âŒ Todos los nodos son identificables<br>
                âŒ Nombres, edades y profesiones visibles<br>
                âŒ Relaciones personales expuestas<br>
                âŒ Grados Ãºnicos permiten identificaciÃ³n<br><br>
                <strong>30 personas identificables<br>43 conexiones visibles</strong>
            </span>
        </div>
        <div class="controls">
            <button onclick="toggleClusters()" id="clusterBtn">ğŸ™ï¸ Agrupar por Ciudades</button>
            <button onclick="detectCommunities()" id="communityBtn">ğŸ” Detectar Comunidades (Louvain)</button>
            <button onclick="applyClusteringPreserving()" id="clusteringBtn" class="automorph-btn">ğŸ¯ Clustering Preserving Randomization</button>
            <button onclick="applySpectralPerturbation()" id="spectralBtn" class="automorph-btn">ğŸŒŠ PerturbaciÃ³n Espectral</button>
            <button onclick="applyKAnonymity()" id="kanonBtn" class="kanon-btn">ğŸŸ£ K-Anonimidad (k=3)</button>
            <button onclick="applyEdgePerturbation()" id="perturbBtn" class="automorph-btn">ğŸ”€ Differential Privacy (Îµ=2.5)</button>
            <button onclick="resetSimulation()">ğŸ”„ Reset Vista</button>
            <button onclick="pauseSimulation()">â¸ï¸ Pausar/Reanudar</button>
        </div>
        <svg id="graph" width="1400" height="800"></svg>
        <div class="tooltip" id="tooltip"></div>
    </div>
    <script>
const originalNodes=[{id:'Ana',edad:22,ciudad:'Barcelona',profesion:'Estudiante'},{id:'Luis',edad:20,ciudad:'Madrid',profesion:'Estudiante'},{id:'MarÃ­a',edad:23,ciudad:'Barcelona',profesion:'Becaria'},{id:'Carlos',edad:21,ciudad:'Valencia',profesion:'Estudiante'},{id:'Sofia',edad:24,ciudad:'Madrid',profesion:'DiseÃ±adora'},{id:'Diego',edad:19,ciudad:'Sevilla',profesion:'Estudiante'},{id:'Laura',edad:22,ciudad:'Barcelona',profesion:'Becaria'},{id:'Pedro',edad:25,ciudad:'Madrid',profesion:'Programador'},{id:'Elena',edad:20,ciudad:'Valencia',profesion:'Estudiante'},{id:'Javier',edad:23,ciudad:'Barcelona',profesion:'Ingeniero'},{id:'Roberto',edad:35,ciudad:'Madrid',profesion:'Arquitecto'},{id:'Carmen',edad:38,ciudad:'Barcelona',profesion:'Abogada'},{id:'Fernando',edad:42,ciudad:'Valencia',profesion:'MÃ©dico'},{id:'Isabel',edad:33,ciudad:'Sevilla',profesion:'Profesora'},{id:'Miguel',edad:40,ciudad:'Madrid',profesion:'Empresario'},{id:'Patricia',edad:36,ciudad:'Barcelona',profesion:'Enfermera'},{id:'AndrÃ©s',edad:44,ciudad:'Valencia',profesion:'Ingeniero'},{id:'Beatriz',edad:31,ciudad:'Madrid',profesion:'Periodista'},{id:'Jorge',edad:39,ciudad:'Barcelona',profesion:'Contador'},{id:'Rosa',edad:37,ciudad:'Sevilla',profesion:'FarmacÃ©utica'},{id:'Antonio',edad:65,ciudad:'Madrid',profesion:'Jubilado'},{id:'Dolores',edad:68,ciudad:'Barcelona',profesion:'Jubilada'},{id:'Francisco',edad:62,ciudad:'Valencia',profesion:'Jubilado'},{id:'Teresa',edad:70,ciudad:'Sevilla',profesion:'Jubilada'},{id:'JosÃ©',edad:66,ciudad:'Madrid',profesion:'Jubilado'},{id:'Pilar',edad:64,ciudad:'Barcelona',profesion:'Jubilada'},{id:'Manuel',edad:69,ciudad:'Valencia',profesion:'Jubilado'},{id:'ConcepciÃ³n',edad:63,ciudad:'Madrid',profesion:'Jubilada'},{id:'RamÃ³n',edad:67,ciudad:'Barcelona',profesion:'Jubilado'},{id:'Mercedes',edad:71,ciudad:'Sevilla',profesion:'Jubilada'}];
const originalLinks=[{source:'Ana',target:'Luis'},{source:'Ana',target:'MarÃ­a'},{source:'Ana',target:'Roberto'},{source:'Ana',target:'Carmen'},{source:'Ana',target:'Dolores'},{source:'Ana',target:'Patricia'},{source:'Ana',target:'Javier'},{source:'Ana',target:'Jorge'},{source:'Luis',target:'MarÃ­a'},{source:'Luis',target:'Carmen'},{source:'Luis',target:'Roberto'},{source:'Luis',target:'Antonio'},{source:'Luis',target:'JosÃ©'},{source:'Luis',target:'ConcepciÃ³n'},{source:'Luis',target:'Miguel'},{source:'MarÃ­a',target:'Patricia'},{source:'MarÃ­a',target:'Dolores'},{source:'MarÃ­a',target:'Pilar'},{source:'MarÃ­a',target:'RamÃ³n'},{source:'MarÃ­a',target:'Jorge'},{source:'Carlos',target:'Sofia'},{source:'Carlos',target:'Fernando'},{source:'Carlos',target:'Elena'},{source:'Carlos',target:'Manuel'},{source:'Carlos',target:'Francisco'},{source:'Sofia',target:'Miguel'},{source:'Sofia',target:'Beatriz'},{source:'Sofia',target:'Antonio'},{source:'Diego',target:'Laura'},{source:'Diego',target:'Isabel'},{source:'Diego',target:'Teresa'},{source:'Laura',target:'Patricia'},{source:'Pedro',target:'Beatriz'},{source:'Pedro',target:'Antonio'},{source:'Elena',target:'Jorge'},{source:'Roberto',target:'Carmen'},{source:'Fernando',target:'Miguel'},{source:'Patricia',target:'Isabel'},{source:'AndrÃ©s',target:'Rosa'},{source:'Dolores',target:'Pilar'},{source:'Francisco',target:'Manuel'},{source:'Teresa',target:'Mercedes'},{source:'RamÃ³n',target:'ConcepciÃ³n'}];
let nodes=JSON.parse(JSON.stringify(originalNodes));
let links=JSON.parse(JSON.stringify(originalLinks));
const colorScale=d3.scaleOrdinal().domain(['Barcelona','Madrid','Valencia','Sevilla']).range(['#e74c3c','#3498db','#2ecc71','#f39c12']);
const degreeColorScale=d3.scaleOrdinal().range(['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#e67e22','#1abc9c','#34495e']);
const automorphColorScale=d3.scaleOrdinal().range(['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#e67e22','#1abc9c','#34495e']);
const clusterCenters={Barcelona:{x:300,y:400},Madrid:{x:700,y:200},Valencia:{x:1100,y:400},Sevilla:{x:700,y:600}};
const svg=d3.select('#graph'),width=+svg.attr('width'),height=+svg.attr('height');
const zoom=d3.zoom().scaleExtent([0.5,3]).on('zoom',(e)=>g.attr('transform',e.transform));
svg.call(zoom);
const g=svg.append('g');
let clustered=false;
let fused=false;
let kanonActive=false;
let perturbActive=false;
let communityActive=false;
let clusteringPreservingActive=false;
let spectralActive=false;
let fusionTimeout=null;
let communities=[];
let spectralPhase='original';
let spectralMetrics={};
const clusterForce=(alpha)=>{
    if(clustered&&!fused&&!kanonActive&&!perturbActive&&!communityActive){
        nodes.forEach(n=>{
            const center=clusterCenters[n.ciudad];
            n.vx-=(n.x-center.x)*alpha*0.3;
            n.vy-=(n.y-center.y)*alpha*0.3;
        });
    }
    if((communityActive||clusteringPreservingActive)&&communities.length>0){
        communities.forEach((comm,idx)=>{
            const centerX=300+(idx%3)*450;
            const centerY=200+Math.floor(idx/3)*300;
            comm.members.forEach(nodeId=>{
                const n=nodes.find(x=>x.id===nodeId);
                if(n){
                    n.vx+=(centerX-n.x)*alpha*0.2;
                    n.vy+=(centerY-n.y)*alpha*0.2;
                }
            });
        });
    }
};
let simulation=d3.forceSimulation(nodes).force('link',d3.forceLink(links).id(d=>d.id).distance(90)).force('charge',d3.forceManyBody().strength(-250)).force('center',d3.forceCenter(width/2,height/2)).force('cluster',clusterForce).force('collision',d3.forceCollide().radius(35));
let link=g.append('g').selectAll('line');
let node=g.append('g').selectAll('circle');
let label=g.append('g').selectAll('text');
const clusterLabels=g.append('g').selectAll('.cluster-label').data(Object.keys(clusterCenters)).enter().append('text').attr('class','cluster-label').text(d=>d).attr('fill',d=>colorScale(d)).attr('x',d=>clusterCenters[d].x).attr('y',d=>clusterCenters[d].y-120);
const tooltip=d3.select('#tooltip');
const warningBox=d3.select('#warningBox');
const warningTitle=d3.select('#warningTitle');
const warningText=d3.select('#warningText');
const clusterBtn=d3.select('#clusterBtn');
const communityBtn=d3.select('#communityBtn');
const clusteringBtn=d3.select('#clusteringBtn');
const spectralBtn=d3.select('#spectralBtn');
const kanonBtn=d3.select('#kanonBtn');
const perturbBtn=d3.select('#perturbBtn');
let isPaused=false;
function updateGraph(){
    link=link.data(links,d=>(d.source.id||d.source)+'-'+(d.target.id||d.target));
    link.exit().remove();
    const linkEnter=link.enter().append('line').attr('class',d=>{if(d.perturbed)return'link perturbed';if(d.removed)return'link removed';if(d.added)return'link added';return'link';});
    link=linkEnter.merge(link);
    node=node.data(nodes,d=>d.id);
    node.exit().remove();
    const nodeEnter=node.enter().append('circle').attr('class',d=>d.isSupernode?'supernode':'node').attr('r',d=>d.isSupernode?50:30).attr('fill',d=>{if(d.isSupernode&&d.communityColor)return d.communityColor;if(fused)return colorScale(d.ciudad);if((communityActive||clusteringPreservingActive)&&d.communityColor)return d.communityColor;if(perturbActive)return'#e74c3c';if(kanonActive&&d.degreeGroup!==undefined)return degreeColorScale(d.degreeGroup);if(clustered)return colorScale(d.ciudad);return'#3498db';}).call(d3.drag().on('start',(e,d)=>{if(!e.active)simulation.alphaTarget(0.3).restart();d.fx=d.x;d.fy=d.y;}).on('drag',(e,d)=>{d.fx=e.x;d.fy=e.y;}).on('end',(e,d)=>{if(!e.active)simulation.alphaTarget(0);d.fx=null;d.fy=null;})).on('mouseover',(e,d)=>{let html='<strong style="font-size:14px">'+d.id+'</strong>';if(d.isSupernode){html+='<br><br>ğŸ”’ <strong>Total personas:</strong> '+d.count;html+='<br>ğŸ“Š <strong>Edad media:</strong> '+d.avgAge.toFixed(1)+' aÃ±os';if(d.profCounts){html+='<br><br>ğŸ’¼ <strong>Por profesiÃ³n:</strong>';Object.keys(d.profCounts).sort((a,b)=>d.profCounts[b]-d.profCounts[a]).forEach(prof=>{html+='<br>      '+prof+': '+d.profCounts[prof];});}if(d.cityCounts){html+='<br><br>ğŸ™ï¸ <strong>Por ciudad:</strong>';Object.keys(d.cityCounts).sort((a,b)=>d.cityCounts[b]-d.cityCounts[a]).forEach(city=>{html+='<br>      '+city+': '+d.cityCounts[city];});}if(d.cityConnections){html+='<br><br>ğŸ”— <strong>Conexiones con otras ciudades:</strong>';const cities=['Barcelona','Madrid','Valencia','Sevilla'];cities.forEach(city=>{if(city!==d.ciudad&&d.cityConnections[city]>0){html+='<br>      '+city+': '+d.cityConnections[city];}});}}else{html+='<br>ğŸ™ï¸ Ciudad: '+d.ciudad+'<br>ğŸ‚ Edad: '+d.edad+' aÃ±os<br>ğŸ’¼ ProfesiÃ³n: '+d.profesion;if((communityActive||clusteringPreservingActive)&&d.community!==undefined){html+='<br><br><strong style="color:'+d.communityColor+';font-size:13px">ğŸ” COMUNIDAD '+(d.community+1)+'</strong>';const comm=communities[d.community];if(comm){html+='<br>ğŸ” TamaÃ±o: '+comm.size+' personas';if(comm.avgAge)html+='<br>ğŸ” Edad media: '+comm.avgAge+' aÃ±os';}}else if(perturbActive&&d.perturbDegree!==undefined){html+='<br><br><strong style="color:#e74c3c;font-size:13px">ğŸ”€ GRADO: '+d.perturbDegree+' conexiones</strong>';html+='<br><strong style="color:#c0392b">ğŸ”€ Red perturbada</strong>';}else if(kanonActive&&d.degree!==undefined){html+='<br><br><strong style="color:#9b59b6;font-size:13px">ğŸŸ£ GRADO: '+d.degree+' conexiones</strong>';if(d.degreeCount!==undefined){html+='<br><strong>ğŸŸ£ Comparte grado con '+(d.degreeCount-1)+' nodos mÃ¡s</strong>';}}}tooltip.style('opacity',1).html(html).style('left',e.clientX+10+'px').style('top',e.clientY+10+'px');}).on('mousemove',(e)=>tooltip.style('left',e.clientX+10+'px').style('top',e.clientY+10+'px')).on('mouseout',()=>{tooltip.style('opacity',0);node.classed('highlighted',false);});
    node=nodeEnter.merge(node);
    node.attr('fill',d=>{if(d.isSupernode&&d.communityColor)return d.communityColor;if(fused)return colorScale(d.ciudad);if((communityActive||clusteringPreservingActive)&&d.communityColor)return d.communityColor;if(perturbActive)return'#e74c3c';if(kanonActive&&d.degreeGroup!==undefined)return degreeColorScale(d.degreeGroup);if(clustered)return colorScale(d.ciudad);return'#3498db';});
    label=label.data(nodes,d=>d.id);
    label.exit().remove();
    const labelEnter=label.enter().append('text').attr('class',d=>d.isSupernode?'supernode-label':'node-label').text(d=>d.id);
    label=labelEnter.merge(label);
    simulation.nodes(nodes);
    simulation.force('link').links(links);
    simulation.alpha(1).restart();
    simulation.on('tick',()=>{link.attr('x1',d=>d.source.x).attr('y1',d=>d.source.y).attr('x2',d=>d.target.x).attr('y2',d=>d.target.y);node.attr('cx',d=>d.x).attr('cy',d=>d.y);label.attr('x',d=>d.x).attr('y',d=>d.y+5);});
}
updateGraph();
function detectCommunities(){
    if(fused||kanonActive||perturbActive||clusteringPreservingActive||spectralActive)return;
    communityActive=true;
    console.log('ğŸ” DETECTANDO COMUNIDADES CON ALGORITMO LOUVAIN');
    const nodeCommunity={};
    nodes.forEach(n=>nodeCommunity[n.id]=-1);
    const adjList={};
    nodes.forEach(n=>adjList[n.id]=[]);
    links.forEach(l=>{
        const s=l.source.id||l.source;
        const t=l.target.id||l.target;
        adjList[s].push(t);
        adjList[t].push(s);
    });
    nodes.forEach((n,idx)=>{
        nodeCommunity[n.id]=idx;
    });
    for(let iter=0;iter<15;iter++){
        let changed=false;
        nodes.forEach(n=>{
            const neighbors=adjList[n.id];
            const commCounts={};
            neighbors.forEach(nb=>{
                const c=nodeCommunity[nb];
                commCounts[c]=(commCounts[c]||0)+1;
            });
            let bestComm=nodeCommunity[n.id];
            let maxCount=0;
            Object.keys(commCounts).forEach(c=>{
                if(commCounts[c]>maxCount){
                    maxCount=commCounts[c];
                    bestComm=parseInt(c);
                }
            });
            if(bestComm!==nodeCommunity[n.id]){
                nodeCommunity[n.id]=bestComm;
                changed=true;
            }
        });
        if(!changed)break;
    }
    const mainComm={};
    nodes.forEach(n=>{
        const c=nodeCommunity[n.id];
        mainComm[c]=(mainComm[c]||0)+1;
    });
    let largestComm=-1;
    let largestSize=0;
    Object.keys(mainComm).forEach(c=>{
        if(mainComm[c]>largestSize){
            largestSize=mainComm[c];
            largestComm=parseInt(c);
        }
    });
    if(largestSize>6){
        console.log('ğŸ” Subdividiendo comunidad grande ('+largestSize+' nodos)...');
        const largeCommNodes=nodes.filter(n=>nodeCommunity[n.id]===largestComm);
        const largeCommIds=largeCommNodes.map(n=>n.id);
        const internalAdjList={};
        largeCommIds.forEach(id=>{
            internalAdjList[id]=adjList[id].filter(nb=>largeCommIds.includes(nb));
        });
        const connectionStrength={};
        largeCommIds.forEach(id1=>{
            largeCommIds.forEach(id2=>{
                if(id1<id2){
                    const commonNeighbors=internalAdjList[id1].filter(nb=>internalAdjList[id2].includes(nb));
                    const directConnection=internalAdjList[id1].includes(id2)?1:0;
                    const strength=directConnection*2+commonNeighbors.length;
                    connectionStrength[id1+'-'+id2]=strength;
                }
            });
        });
        const numSubComms=Math.min(4,Math.floor(largestSize/4));
        const subCommIds=[];
        for(let i=0;i<numSubComms;i++){
            subCommIds.push(nodes.length+i);
        }
        const usedSeeds=new Set();
        const subCommMembers={};
        subCommIds.forEach(scId=>subCommMembers[scId]=[]);
        const sortedByDegree=[...largeCommIds].sort((a,b)=>internalAdjList[b].length-internalAdjList[a].length);
        for(let i=0;i<numSubComms&&i<sortedByDegree.length;i++){
            const seed=sortedByDegree[i];
            usedSeeds.add(seed);
            subCommMembers[subCommIds[i]].push(seed);
            nodeCommunity[seed]=subCommIds[i];
        }
        const unassigned=largeCommIds.filter(id=>!usedSeeds.has(id));
        unassigned.forEach(nodeId=>{
            const scores={};
            subCommIds.forEach(scId=>{
                scores[scId]=0;
                subCommMembers[scId].forEach(memberId=>{
                    const key=[nodeId,memberId].sort().join('-');
                    scores[scId]+=(connectionStrength[key]||0);
                });
            });
            let bestComm=subCommIds[0];
            let bestScore=scores[bestComm];
            subCommIds.forEach(scId=>{
                if(scores[scId]>bestScore){
                    bestScore=scores[scId];
                    bestComm=scId;
                }
            });
            nodeCommunity[nodeId]=bestComm;
            subCommMembers[bestComm].push(nodeId);
        });
        for(let refineIter=0;refineIter<5;refineIter++){
            let moved=false;
            largeCommIds.forEach(nodeId=>{
                const currentComm=nodeCommunity[nodeId];
                const scores={};
                subCommIds.forEach(scId=>{
                    if(scId===currentComm){
                        scores[scId]=internalAdjList[nodeId].filter(nb=>nodeCommunity[nb]===currentComm&&nb!==nodeId).length;
                    }else{
                        scores[scId]=internalAdjList[nodeId].filter(nb=>nodeCommunity[nb]===scId).length;
                    }
                });
                let bestComm=currentComm;
                let bestScore=scores[currentComm];
                subCommIds.forEach(scId=>{
                    if(scores[scId]>bestScore){
                        bestScore=scores[scId];
                        bestComm=scId;
                    }
                });
                if(bestComm!==currentComm){
                    nodeCommunity[nodeId]=bestComm;
                    moved=true;
                }
            });
            if(!moved)break;
        }
        const finalSubComms={};
        largeCommIds.forEach(id=>{
            const c=nodeCommunity[id];
            if(!finalSubComms[c])finalSubComms[c]=0;
            finalSubComms[c]++;
        });
        console.log('  âœ“ Subdividida en '+Object.keys(finalSubComms).length+' subcomunidades:');
        Object.keys(finalSubComms).forEach(c=>{
            console.log('    - Subcomunidad: '+finalSubComms[c]+' nodos');
        });
    }
    const commMap={};
    nodes.forEach(n=>{
        const c=nodeCommunity[n.id];
        if(!commMap[c])commMap[c]=[];
        commMap[c].push(n.id);
    });
    communities=[];
    const commColors=d3.scaleOrdinal(d3.schemeCategory10);
    Object.keys(commMap).forEach((c,idx)=>{
        const members=commMap[c];
        const memberNodes=members.map(id=>originalNodes.find(x=>x.id===id));
        const avgAge=(memberNodes.reduce((sum,n)=>sum+n.edad,0)/memberNodes.length).toFixed(1);
        const cities={};
        memberNodes.forEach(n=>{cities[n.ciudad]=(cities[n.ciudad]||0)+1;});
        const professions={};
        memberNodes.forEach(n=>{professions[n.profesion]=(professions[n.profesion]||0)+1;});
        const internalEdges=links.filter(l=>{
            const s=l.source.id||l.source;
            const t=l.target.id||l.target;
            return members.includes(s)&&members.includes(t);
        }).length;
        const externalEdges=links.filter(l=>{
            const s=l.source.id||l.source;
            const t=l.target.id||l.target;
            return(members.includes(s)&&!members.includes(t))||(members.includes(t)&&!members.includes(s));
        }).length;
        communities.push({
            id:idx,
            members:members,
            size:members.length,
            avgAge:avgAge,
            cities:cities,
            professions:professions,
            internalEdges:internalEdges,
            externalEdges:externalEdges,
            color:commColors(idx)
        });
        members.forEach(nodeId=>{
            const n=nodes.find(x=>x.id===nodeId);
            if(n){
                n.community=idx;
                n.communityColor=commColors(idx);
            }
        });
    });
    console.log('âœ“ Detectadas '+communities.length+' comunidades');
    communities.forEach((comm,idx)=>{
        console.log('  Comunidad '+(idx+1)+': '+comm.size+' nodos, '+comm.internalEdges+' aristas internas, '+comm.externalEdges+' aristas externas');
    });
    let statsHTML='<strong>ESTADÃSTICAS POR COMUNIDAD:</strong><br><br>';
    communities.forEach((comm,idx)=>{
        statsHTML+='<strong style="color:'+comm.color+'">ğŸ“Š Comunidad '+(idx+1)+'</strong><br>';
        statsHTML+='   â€¢ TamaÃ±o: '+comm.size+' personas<br>';
        statsHTML+='   â€¢ Edad media: '+comm.avgAge+' aÃ±os<br>';
        statsHTML+='   â€¢ Ciudades: '+Object.keys(comm.cities).map(c=>c+' ('+comm.cities[c]+')').join(', ')+'<br>';
        statsHTML+='   â€¢ Conexiones internas: '+comm.internalEdges+'<br>';
        statsHTML+='   â€¢ Conexiones externas: '+comm.externalEdges+'<br><br>';
    });
    warningBox.classed('protected',true).classed('anonymous',false).classed('kanon',false).classed('automorph',false);
    warningTitle.html('ğŸ” COMUNIDADES DETECTADAS (Algoritmo Louvain)');
    warningText.html('ğŸ” '+communities.length+' comunidades encontradas<br>ğŸ” Nodos agrupados por conectividad<br>ğŸ” Mismo COLOR = misma comunidad<br><br>'+statsHTML+'<strong style="color:#27ae60">âœ“ Estructura comunitaria revelada</strong>');
    communityBtn.classed('active',true).attr('disabled','disabled');
    clusterBtn.attr('disabled','disabled');
    clusteringBtn.attr('disabled','disabled');
    kanonBtn.attr('disabled','disabled');
    perturbBtn.attr('disabled','disabled');
    spectralBtn.attr('disabled','disabled');
    updateGraph();
    setTimeout(()=>{
        console.log('ğŸ”’ Aplicando generalizaciÃ³n de comunidades...');
        const supernodes=[];
        communities.forEach((comm,idx)=>{
            const memberNodes=comm.members.map(id=>originalNodes.find(x=>x.id===id));
            const avgAge=(memberNodes.reduce((sum,n)=>sum+n.edad,0)/memberNodes.length).toFixed(1);
            const profCounts={};
            memberNodes.forEach(n=>{profCounts[n.profesion]=(profCounts[n.profesion]||0)+1;});
            const topProf=Object.keys(profCounts).sort((a,b)=>profCounts[b]-profCounts[a])[0];
            const cityCounts={};
            memberNodes.forEach(n=>{cityCounts[n.ciudad]=(cityCounts[n.ciudad]||0)+1;});
            const topCity=Object.keys(cityCounts).sort((a,b)=>cityCounts[b]-cityCounts[a])[0];
            supernodes.push({
                id:'Comunidad '+(idx+1),
                isSupernode:true,
                ciudad:topCity,
                count:comm.size,
                avgAge:parseFloat(avgAge),
                professions:Object.keys(profCounts),
                profCounts:profCounts,
                cityCounts:cityCounts,
                members:comm.members,
                internalEdges:comm.internalEdges,
                externalEdges:comm.externalEdges,
                color:comm.color,
                communityColor:comm.color
            });
        });
        const intercommunityLinks=[];
        const addedPairs=new Set();
        links.forEach(l=>{
            const s=l.source.id||l.source;
            const t=l.target.id||l.target;
            const sComm=communities.findIndex(c=>c.members.includes(s));
            const tComm=communities.findIndex(c=>c.members.includes(t));
            if(sComm!==tComm&&sComm>=0&&tComm>=0){
                const key=[sComm,tComm].sort().join('-');
                if(!addedPairs.has(key)){
                    addedPairs.add(key);
                    intercommunityLinks.push({
                        source:'Comunidad '+(sComm+1),
                        target:'Comunidad '+(tComm+1)
                    });
                }
            }
        });
        nodes=supernodes;
        links=intercommunityLinks;
        simulation.force('charge',d3.forceManyBody().strength(-400));
        simulation.force('collision',d3.forceCollide().radius(60));
        simulation.force('link').distance(250);
        let generalHTML='<strong>COMUNIDADES GENERALIZADAS:</strong><br><br>';
        supernodes.forEach((sn,idx)=>{
            generalHTML+='<strong style="color:'+sn.color+'">ğŸ”’ '+sn.id+'</strong><br>';
            generalHTML+='   â€¢ Personas: '+sn.count+'<br>';
            generalHTML+='   â€¢ Edad media: '+sn.avgAge+' aÃ±os<br>';
            generalHTML+='   â€¢ Ciudad principal: '+Object.keys(sn.cityCounts).sort((a,b)=>sn.cityCounts[b]-sn.cityCounts[a])[0]+'<br>';
            generalHTML+='   â€¢ ProfesiÃ³n principal: '+Object.keys(sn.profCounts).sort((a,b)=>sn.profCounts[b]-sn.profCounts[a])[0]+'<br><br>';
        });
        warningBox.classed('protected',false).classed('anonymous',true).classed('kanon',false).classed('automorph',false);
        warningTitle.html('ğŸ”’ GENERALIZACIÃ“N DE COMUNIDADES');
        warningText.html('ğŸ”’ Identidades individuales eliminadas<br>ğŸ”’ Solo promedios y agregados<br>ğŸ”’ '+supernodes.length+' supernodos comunitarios<br>ğŸ”’ '+intercommunityLinks.length+' conexiones entre comunidades<br><br>'+generalHTML+'<strong style="color:#27ae60">âœ“ MÃ¡xima privacidad garantizada</strong>');
        updateGraph();
    },4000);
}
function applyClusteringPreserving(){
    if(fused||clustered||kanonActive||perturbActive||communityActive||spectralActive)return;
    clusteringPreservingActive=true;
    console.log('ğŸ¯ APLICANDO CLUSTERING PRESERVING RANDOMIZATION');
    const nodeCommunity={};
    nodes.forEach(n=>nodeCommunity[n.id]=-1);
    const adjList={};
    nodes.forEach(n=>adjList[n.id]=[]);
    links.forEach(l=>{
        const s=l.source.id||l.source;
        const t=l.target.id||l.target;
        adjList[s].push(t);
        adjList[t].push(s);
    });
    nodes.forEach((n,idx)=>nodeCommunity[n.id]=idx);
    for(let iter=0;iter<15;iter++){
        let changed=false;
        nodes.forEach(n=>{
            const neighbors=adjList[n.id];
            const commCounts={};
            neighbors.forEach(nb=>{
                const c=nodeCommunity[nb];
                commCounts[c]=(commCounts[c]||0)+1;
            });
            let bestComm=nodeCommunity[n.id];
            let maxCount=0;
            Object.keys(commCounts).forEach(c=>{
                if(commCounts[c]>maxCount){
                    maxCount=commCounts[c];
                    bestComm=parseInt(c);
                }
            });
            if(bestComm!==nodeCommunity[n.id]){
                nodeCommunity[n.id]=bestComm;
                changed=true;
            }
        });
        if(!changed)break;
    }
    const mainComm={};
    nodes.forEach(n=>{
        const c=nodeCommunity[n.id];
        mainComm[c]=(mainComm[c]||0)+1;
    });
    let largestComm=-1;
    let largestSize=0;
    Object.keys(mainComm).forEach(c=>{
        if(mainComm[c]>largestSize){
            largestSize=mainComm[c];
            largestComm=parseInt(c);
        }
    });
    if(largestSize>6){
        const largeCommNodes=nodes.filter(n=>nodeCommunity[n.id]===largestComm);
        const largeCommIds=largeCommNodes.map(n=>n.id);
        const internalAdjList={};
        largeCommIds.forEach(id=>internalAdjList[id]=adjList[id].filter(nb=>largeCommIds.includes(nb)));
        const connectionStrength={};
        largeCommIds.forEach(id1=>{
            largeCommIds.forEach(id2=>{
                if(id1<id2){
                    const commonNeighbors=internalAdjList[id1].filter(nb=>internalAdjList[id2].includes(nb));
                    const directConnection=internalAdjList[id1].includes(id2)?1:0;
                    const strength=directConnection*2+commonNeighbors.length;
                    connectionStrength[id1+'-'+id2]=strength;
                }
            });
        });
        const numSubComms=Math.min(4,Math.floor(largestSize/4));
        const subCommIds=[];
        for(let i=0;i<numSubComms;i++)subCommIds.push(nodes.length+i);
        const usedSeeds=new Set();
        const subCommMembers={};
        subCommIds.forEach(scId=>subCommMembers[scId]=[]);
        const sortedByDegree=[...largeCommIds].sort((a,b)=>internalAdjList[b].length-internalAdjList[a].length);
        for(let i=0;i<numSubComms&&i<sortedByDegree.length;i++){
            const seed=sortedByDegree[i];
            usedSeeds.add(seed);
            subCommMembers[subCommIds[i]].push(seed);
            nodeCommunity[seed]=subCommIds[i];
        }
        const unassigned=largeCommIds.filter(id=>!usedSeeds.has(id));
        unassigned.forEach(nodeId=>{
            const scores={};
            subCommIds.forEach(scId=>{
                scores[scId]=0;
                subCommMembers[scId].forEach(memberId=>{
                    const key=[nodeId,memberId].sort().join('-');
                    scores[scId]+=(connectionStrength[key]||0);
                });
            });
            let bestComm=subCommIds[0];
            let bestScore=scores[bestComm];
            subCommIds.forEach(scId=>{
                if(scores[scId]>bestScore){
                    bestScore=scores[scId];
                    bestComm=scId;
                }
            });
            nodeCommunity[nodeId]=bestComm;
            subCommMembers[bestComm].push(nodeId);
        });
        for(let refineIter=0;refineIter<5;refineIter++){
            let moved=false;
            largeCommIds.forEach(nodeId=>{
                const currentComm=nodeCommunity[nodeId];
                const scores={};
                subCommIds.forEach(scId=>{
                    if(scId===currentComm){
                        scores[scId]=internalAdjList[nodeId].filter(nb=>nodeCommunity[nb]===currentComm&&nb!==nodeId).length;
                    }else{
                        scores[scId]=internalAdjList[nodeId].filter(nb=>nodeCommunity[nb]===scId).length;
                    }
                });
                let bestComm=currentComm;
                let bestScore=scores[currentComm];
                subCommIds.forEach(scId=>{
                    if(scores[scId]>bestScore){
                        bestScore=scores[scId];
                        bestComm=scId;
                    }
                });
                if(bestComm!==currentComm){
                    nodeCommunity[nodeId]=bestComm;
                    moved=true;
                }
            });
            if(!moved)break;
        }
    }
    const commMap={};
    nodes.forEach(n=>{
        const c=nodeCommunity[n.id];
        if(!commMap[c])commMap[c]=[];
        commMap[c].push(n.id);
    });
    communities=[];
    const commColors=d3.scaleOrdinal(d3.schemeCategory10);
    Object.keys(commMap).forEach((c,idx)=>{
        const members=commMap[c];
        communities.push({id:idx,members:members,size:members.length,color:commColors(idx)});
        members.forEach(nodeId=>{
            const n=nodes.find(x=>x.id===nodeId);
            if(n){
                n.community=idx;
                n.communityColor=commColors(idx);
            }
        });
    });
    console.log('âœ“ Detectadas '+communities.length+' comunidades para preservar');
    const p_intra=0.15;
    const p_inter=0.02;
    const newLinks=[];
    const existingEdges=new Set();
    links.forEach(l=>{
        const s=l.source.id||l.source;
        const t=l.target.id||l.target;
        const key=[s,t].sort().join('-');
        existingEdges.add(key);
    });
    let intraAdded=0;
    let intraRemoved=0;
    let interAdded=0;
    let interRemoved=0;
    for(let i=0;i<nodes.length;i++){
        for(let j=i+1;j<nodes.length;j++){
            const nodeA=nodes[i].id;
            const nodeB=nodes[j].id;
            const commA=nodeCommunity[nodeA];
            const commB=nodeCommunity[nodeB];
            const sameComm=(commA===commB);
            const key=[nodeA,nodeB].sort().join('-');
            const edgeExists=existingEdges.has(key);
            const prob=sameComm?p_intra:p_inter;
            if(edgeExists){
                if(Math.random()>prob){
                    newLinks.push({source:nodeA,target:nodeB});
                }else{
                    if(sameComm)intraRemoved++;else interRemoved++;
                }
            }else{
                if(Math.random()<prob){
                    newLinks.push({source:nodeA,target:nodeB,perturbed:true});
                    if(sameComm)intraAdded++;else interAdded++;
                }
            }
        }
    }
    links=newLinks;
    console.log('âœ“ Aristas intra-comunidad: +'+intraAdded+' -'+intraRemoved);
    console.log('âœ“ Aristas inter-comunidad: +'+interAdded+' -'+interRemoved);
    console.log('âœ“ Total aristas: '+links.length);
    let statsHTML='<strong>PRESERVACIÃ“N DE CLUSTERING:</strong><br><br>';
    statsHTML+='<strong style="color:#e67e22">ğŸ“Š Cambios en aristas:</strong><br>';
    statsHTML+='   â€¢ Intra-comunidad: +'+intraAdded+' / -'+intraRemoved+'<br>';
    statsHTML+='   â€¢ Inter-comunidad: +'+interAdded+' / -'+interRemoved+'<br>';
    statsHTML+='   â€¢ Total: '+links.length+' aristas<br><br>';
    statsHTML+='<strong style="color:#2ecc71">ğŸ¯ Comunidades preservadas: '+communities.length+'</strong><br>';
    communities.forEach((comm,idx)=>{
        statsHTML+='<strong style="color:'+comm.color+'">   â€¢ Comunidad '+(idx+1)+':</strong> '+comm.size+' nodos<br>';
    });
    warningBox.classed('protected',false).classed('anonymous',false).classed('kanon',false).classed('automorph',true);
    warningTitle.html('ğŸ¯ CLUSTERING PRESERVING RANDOMIZATION');
    warningText.html('ğŸ¯ <strong>Preserva estructura comunitaria</strong><br>ğŸ¯ Modifica principalmente intra-comunidad<br>ğŸ¯ Mantiene organizaciÃ³n general<br><br>'+statsHTML+'<br><strong style="color:#27ae60">âœ“ Equilibrio privacidad-utilidad</strong>');
    clusteringBtn.classed('active',true).attr('disabled','disabled');
    clusterBtn.attr('disabled','disabled');
    communityBtn.attr('disabled','disabled');
    kanonBtn.attr('disabled','disabled');
    perturbBtn.attr('disabled','disabled');
    spectralBtn.attr('disabled','disabled');
    updateGraph();
    setTimeout(()=>{
        console.log('ğŸ¯ Revelando comunidades preservadas...');
        node.transition().duration(1500).attr('fill',d=>d.communityColor);
        let finalHTML='<strong>COMUNIDADES PRESERVADAS:</strong><br><br>';
        finalHTML+='<strong style="color:#2ecc71">âœ“ Las comunidades SE MANTIENEN</strong><br>';
        finalHTML+='<strong style="color:#2ecc71">âœ“ A pesar de aristas modificadas</strong><br><br>';
        communities.forEach((comm,idx)=>{
            finalHTML+='<strong style="color:'+comm.color+'">ğŸ“Š Comunidad '+(idx+1)+':</strong> '+comm.size+' nodos<br>';
        });
        finalHTML+='<br><strong style="color:#27ae60">ğŸ¯ Clustering preservado con Ã©xito</strong>';
        warningTitle.html('ğŸ¯ COMUNIDADES PRESERVADAS');
        warningText.html(finalHTML);
    },8000);
}
function calculateDegree(){
    const degreeMap={};
    nodes.forEach(n=>{
        const degree=links.filter(l=>(l.source.id||l.source)===n.id||(l.target.id||l.target)===n.id).length;
        degreeMap[n.id]=degree;
    });
    const avgDegree=Object.values(degreeMap).reduce((a,b)=>a+b,0)/nodes.length;
    const maxDegree=Math.max(...Object.values(degreeMap));
    const minDegree=Math.min(...Object.values(degreeMap));
    let html='<strong>Grado medio: '+avgDegree.toFixed(2)+'</strong> | MÃ¡x: '+maxDegree+' | MÃ­n: '+minDegree+' | Aristas: '+links.length;
    d3.select('#degreeResult').html(html);
    spectralMetrics['degree'+spectralPhase]=avgDegree;
    return avgDegree;
}
function calculateClustering(){
    const adjMatrix=[];
    for(let i=0;i<nodes.length;i++){
        adjMatrix[i]=[];
        for(let j=0;j<nodes.length;j++){
            adjMatrix[i][j]=0;
        }
    }
    links.forEach(l=>{
        const si=nodes.findIndex(n=>n.id===(l.source.id||l.source));
        const ti=nodes.findIndex(n=>n.id===(l.target.id||l.target));
        if(si>=0&&ti>=0){
            adjMatrix[si][ti]=1;
            adjMatrix[ti][si]=1;
        }
    });
    let avgClustering=0;
    let totalNodes=0;
    nodes.forEach(n=>{
        const neighbors=[];
        links.forEach(l=>{
            if((l.source.id||l.source)===n.id)neighbors.push(l.target.id||l.target);
            if((l.target.id||l.target)===n.id)neighbors.push(l.source.id||l.source);
        });
        if(neighbors.length<2)return;
        let triangles=0;
        for(let i=0;i<neighbors.length;i++){
            for(let j=i+1;j<neighbors.length;j++){
                const ni=nodes.findIndex(x=>x.id===neighbors[i]);
                const nj=nodes.findIndex(x=>x.id===neighbors[j]);
                if(ni>=0&&nj>=0&&adjMatrix[ni][nj]===1)triangles++;
            }
        }
        const possibleTriangles=(neighbors.length*(neighbors.length-1))/2;
        const coeff=possibleTriangles>0?triangles/possibleTriangles:0;
        avgClustering+=coeff;
        totalNodes++;
    });
    avgClustering=totalNodes>0?avgClustering/totalNodes:0;
    let html='<strong>Clustering: '+avgClustering.toFixed(3)+'</strong> | Tendencia a formar triÃ¡ngulos (0-1)';
    d3.select('#clusteringResult').html(html);
    spectralMetrics['clustering'+spectralPhase]=avgClustering;
    return avgClustering;
}
function calculateBetweenness(){
    const betweenessCentrality={};
    nodes.forEach(n=>betweenessCentrality[n.id]=0);
    nodes.forEach(s=>{
        const stack=[];
        const paths={};
        const sigma={};
        const dist={};
        const pred={};
        nodes.forEach(w=>{
            pred[w.id]=[];
            paths[w.id]=[];
            sigma[w.id]=0;
            dist[w.id]=-1;
        });
        sigma[s.id]=1;
        dist[s.id]=0;
        const queue=[s.id];
        while(queue.length>0){
            const v=queue.shift();
            stack.push(v);
            const neighbors=[];
            links.forEach(l=>{
                if((l.source.id||l.source)===v)neighbors.push(l.target.id||l.target);
                if((l.target.id||l.target)===v)neighbors.push(l.source.id||l.source);
            });
            neighbors.forEach(w=>{
                if(dist[w]===-1){
                    dist[w]=dist[v]+1;
                    queue.push(w);
                }
                if(dist[w]===dist[v]+1){
                    sigma[w]+=sigma[v];
                    pred[w].push(v);
                }
            });
        }
        const delta={};
        nodes.forEach(v=>delta[v.id]=0);
        while(stack.length>0){
            const w=stack.pop();
            pred[w].forEach(v=>{
                delta[v]+=(sigma[v]/sigma[w])*(1+delta[w]);
            });
            if(w!==s.id)betweenessCentrality[w]+=delta[w];
        }
    });
    const maxBetweenness=Math.max(...Object.values(betweenessCentrality));
    const avgBetweenness=Object.values(betweenessCentrality).reduce((a,b)=>a+b,0)/nodes.length;
    const topNodes=Object.keys(betweenessCentrality).sort((a,b)=>betweenessCentrality[b]-betweenessCentrality[a]).slice(0,3);
    let html='<strong>Centralidad mÃ¡x: '+maxBetweenness.toFixed(2)+'</strong> | Media: '+avgBetweenness.toFixed(2)+' | Top: '+topNodes[0]+' ('+betweenessCentrality[topNodes[0]].toFixed(1)+')';
    d3.select('#centralityResult').html(html);
    spectralMetrics['betweenness'+spectralPhase]=maxBetweenness;
    return maxBetweenness;
}
function compareMetrics(){
    let html='<div style=\"background:rgba(255,255,255,0.3);padding:10px;border-radius:5px;margin-top:5px;\"><strong>ğŸ“Š COMPARACIÃ“N:</strong><br>';
    if(spectralMetrics['degreeoriginal']!==undefined&&spectralMetrics['degreeperturbed']!==undefined){
        const origDeg=spectralMetrics['degreeoriginal'];
        const pertDeg=spectralMetrics['degreeperturbed'];
        const percDeg=(Math.abs(pertDeg-origDeg)/origDeg*100).toFixed(1);
        html+='â€¢ <strong>Grado:</strong> '+origDeg.toFixed(2)+' â†’ '+pertDeg.toFixed(2)+' ('+percDeg+'%) ';
    }
    if(spectralMetrics['clusteringoriginal']!==undefined&&spectralMetrics['clusteringperturbed']!==undefined){
        const origClust=spectralMetrics['clusteringoriginal'];
        const pertClust=spectralMetrics['clusteringperturbed'];
        const percClust=(Math.abs(pertClust-origClust)/(origClust+0.01)*100).toFixed(1);
        html+='â€¢ <strong>Clustering:</strong> '+origClust.toFixed(3)+' â†’ '+pertClust.toFixed(3)+' ('+percClust+'%) ';
    }
    if(spectralMetrics['betweennessoriginal']!==undefined&&spectralMetrics['betweennessperturbed']!==undefined){
        const origBet=spectralMetrics['betweennessoriginal'];
        const pertBet=spectralMetrics['betweennessperturbed'];
        const percBet=(Math.abs(pertBet-origBet)/(origBet+0.01)*100).toFixed(1);
        html+='â€¢ <strong>Centralidad:</strong> '+origBet.toFixed(2)+' â†’ '+pertBet.toFixed(2)+' ('+percBet+'%)<br>';
    }
    const allPreserved=(
        (spectralMetrics['degreeperturbed']&&Math.abs(spectralMetrics['degreeperturbed']-spectralMetrics['degreeoriginal'])/spectralMetrics['degreeoriginal']<0.1)&&
        (spectralMetrics['clusteringperturbed']&&Math.abs(spectralMetrics['clusteringperturbed']-spectralMetrics['clusteringoriginal'])/(spectralMetrics['clusteringoriginal']+0.01)<0.15)
    );
    if(allPreserved){
        html+='<strong style=\"color:#27ae60\">âœ“ Propiedades globales preservadas</strong>';
    }else{
        html+='<strong style=\"color:#f39c12\">âš  Propiedades aproximadas</strong>';
    }
    html+='</div>';
    d3.select('#comparisonResult').html(html);
}
function applySpectralPerturbation(){
    if(fused||clustered||kanonActive||communityActive||clusteringPreservingActive||perturbActive)return;
    spectralActive=true;
    spectralPhase='original';
    spectralMetrics={};
    console.log('ğŸŒŠ MODO PERTURBACIÃ“N ESPECTRAL ACTIVADO');
    warningBox.classed('protected',false).classed('anonymous',false).classed('kanon',false).classed('automorph',true);
    warningTitle.html('ğŸŒŠ PERTURBACIÃ“N ESPECTRAL - GRAFO ORIGINAL');
    let html='<strong>ANÃLISIS DEL GRAFO ORIGINAL:</strong> '+nodes.length+' nodos â€¢ '+links.length+' aristas<br><br>';
    html+='<div class=\"metric-row\">';
    html+='<button onclick=\"calculateDegree()\" class=\"metric-btn btn-degree\">ğŸ“Š Grado Medio</button>';
    html+='<div id=\"degreeResult\" class=\"metric-result\"><em>Click para calcular</em></div>';
    html+='</div>';
    html+='<div class=\"metric-row\">';
    html+='<button onclick=\"calculateClustering()\" class=\"metric-btn btn-clustering\">ğŸ”º Clustering</button>';
    html+='<div id=\"clusteringResult\" class=\"metric-result result-clustering\"><em>Click para calcular</em></div>';
    html+='</div>';
    html+='<div class=\"metric-row\">';
    html+='<button onclick=\"calculateBetweenness()\" class=\"metric-btn btn-centrality\">ğŸ“ Centralidad</button>';
    html+='<div id=\"centralityResult\" class=\"metric-result result-centrality\"><em>Click para calcular</em></div>';
    html+='</div><br>';
    html+='<button onclick=\"perturbGraph()\" class=\"metric-btn btn-perturb\">ğŸŒŠ PERTURBAR GRAFO</button>';
    warningText.html(html);
    spectralBtn.classed('active',true).attr('disabled','disabled');
    clusterBtn.attr('disabled','disabled');
    communityBtn.attr('disabled','disabled');
    clusteringBtn.attr('disabled','disabled');
    kanonBtn.attr('disabled','disabled');
    perturbBtn.attr('disabled','disabled');
    spectralBtn.classed('active',true).attr('disabled','disabled');
}
function perturbGraph(){
    console.log('ğŸŒŠ PERTURBANDO GRAFO...');
    const adjMatrix=[];
    for(let i=0;i<nodes.length;i++){
        adjMatrix[i]=[];
        for(let j=0;j<nodes.length;j++){
            adjMatrix[i][j]=0;
        }
    }
    links.forEach(l=>{
        const si=nodes.findIndex(n=>n.id===(l.source.id||l.source));
        const ti=nodes.findIndex(n=>n.id===(l.target.id||l.target));
        if(si>=0&&ti>=0){
            adjMatrix[si][ti]=1;
            adjMatrix[ti][si]=1;
        }
    });
    const originalDegreeMap={};
    nodes.forEach(n=>{
        const degree=links.filter(l=>(l.source.id||l.source)===n.id||(l.target.id||l.target)===n.id).length;
        originalDegreeMap[n.id]=degree;
    });
    const originalAvgDegree=Object.values(originalDegreeMap).reduce((a,b)=>a+b,0)/nodes.length;
    let originalAvgClustering=0;
    nodes.forEach(n=>{
        const neighbors=[];
        links.forEach(l=>{
            if((l.source.id||l.source)===n.id)neighbors.push(l.target.id||l.target);
            if((l.target.id||l.target)===n.id)neighbors.push(l.source.id||l.source);
        });
        if(neighbors.length<2)return;
        let triangles=0;
        for(let i=0;i<neighbors.length;i++){
            for(let j=i+1;j<neighbors.length;j++){
                const ni=nodes.findIndex(x=>x.id===neighbors[i]);
                const nj=nodes.findIndex(x=>x.id===neighbors[j]);
                if(ni>=0&&nj>=0&&adjMatrix[ni][nj]===1)triangles++;
            }
        }
        const possibleTriangles=(neighbors.length*(neighbors.length-1))/2;
        const coeff=possibleTriangles>0?triangles/possibleTriangles:0;
        originalAvgClustering+=coeff;
    });
    originalAvgClustering/=nodes.length;
    console.log('âœ“ Grado medio original: '+originalAvgDegree.toFixed(2));
    console.log('âœ“ Clustering medio original: '+originalAvgClustering.toFixed(3));
    const maxIterations=200;
    const tolerance=0.05;
    let bestLinks=[...links];
    let bestError=Infinity;
    for(let iter=0;iter<maxIterations;iter++){
        const candidateLinks=[];
        const existingEdges=new Set();
        links.forEach(l=>{
            const s=l.source.id||l.source;
            const t=l.target.id||l.target;
            const key=[s,t].sort().join('-');
            existingEdges.add(key);
        });
        links.forEach(l=>{
            if(Math.random()>0.3){
                candidateLinks.push({source:l.source.id||l.source,target:l.target.id||l.target});
            }
        });
        const allPairs=[];
        for(let i=0;i<nodes.length;i++){
            for(let j=i+1;j<nodes.length;j++){
                const key=[nodes[i].id,nodes[j].id].sort().join('-');
                if(!existingEdges.has(key)){
                    allPairs.push([nodes[i].id,nodes[j].id]);
                }
            }
        }
        const numToAdd=Math.floor(links.length*0.4);
        for(let k=0;k<numToAdd&&allPairs.length>0;k++){
            const idx=Math.floor(Math.random()*allPairs.length);
            const pair=allPairs.splice(idx,1)[0];
            candidateLinks.push({source:pair[0],target:pair[1],perturbed:true});
        }
        const newDegreeMap={};
        nodes.forEach(n=>newDegreeMap[n.id]=0);
        candidateLinks.forEach(l=>{
            newDegreeMap[l.source]++;
            newDegreeMap[l.target]++;
        });
        const newAvgDegree=Object.values(newDegreeMap).reduce((a,b)=>a+b,0)/nodes.length;
        const degreeError=Math.abs(newAvgDegree-originalAvgDegree)/originalAvgDegree;
        const newAdjMatrix=[];
        for(let i=0;i<nodes.length;i++){
            newAdjMatrix[i]=[];
            for(let j=0;j<nodes.length;j++){
                newAdjMatrix[i][j]=0;
            }
        }
        candidateLinks.forEach(l=>{
            const si=nodes.findIndex(n=>n.id===l.source);
            const ti=nodes.findIndex(n=>n.id===l.target);
            if(si>=0&&ti>=0){
                newAdjMatrix[si][ti]=1;
                newAdjMatrix[ti][si]=1;
            }
        });
        let newAvgClustering=0;
        nodes.forEach(n=>{
            const neighbors=[];
            candidateLinks.forEach(l=>{
                if(l.source===n.id)neighbors.push(l.target);
                if(l.target===n.id)neighbors.push(l.source);
            });
            if(neighbors.length<2)return;
            let triangles=0;
            for(let i=0;i<neighbors.length;i++){
                for(let j=i+1;j<neighbors.length;j++){
                    const ni=nodes.findIndex(x=>x.id===neighbors[i]);
                    const nj=nodes.findIndex(x=>x.id===neighbors[j]);
                    if(ni>=0&&nj>=0&&newAdjMatrix[ni][nj]===1)triangles++;
                }
            }
            const possibleTriangles=(neighbors.length*(neighbors.length-1))/2;
            const coeff=possibleTriangles>0?triangles/possibleTriangles:0;
            newAvgClustering+=coeff;
        });
        newAvgClustering/=nodes.length;
        const clusteringError=Math.abs(newAvgClustering-originalAvgClustering)/(originalAvgClustering+0.01);
        const totalError=degreeError+clusteringError;
        if(totalError<bestError){
            bestError=totalError;
            bestLinks=[...candidateLinks];
            if(totalError<tolerance)break;
        }
    }
    links=bestLinks;
    spectralPhase='perturbed';
    const edgesAdded=links.filter(l=>l.perturbed).length;
    const edgesKept=links.length-edgesAdded;
    console.log('âœ“ PerturbaciÃ³n completada');
    warningBox.classed('protected',false).classed('anonymous',false).classed('kanon',false).classed('automorph',true);
    warningTitle.html('ğŸŒŠ PERTURBACIÃ“N ESPECTRAL - GRAFO PERTURBADO');
    let html='<strong>GRAFO PERTURBADO:</strong> Mantenidas: '+edgesKept+' â€¢ AÃ±adidas: <span style=\"color:#fff\">'+edgesAdded+'</span> â€¢ Total: '+links.length+'<br><br>';
    html+='<div class=\"metric-row\">';
    html+='<button onclick=\"calculateDegree()\" class=\"metric-btn btn-degree\">ğŸ“Š Grado Medio</button>';
    html+='<div id=\"degreeResult\" class=\"metric-result\"><em>Click para recalcular</em></div>';
    html+='</div>';
    html+='<div class=\"metric-row\">';
    html+='<button onclick=\"calculateClustering()\" class=\"metric-btn btn-clustering\">ğŸ”º Clustering</button>';
    html+='<div id=\"clusteringResult\" class=\"metric-result result-clustering\"><em>Click para recalcular</em></div>';
    html+='</div>';
    html+='<div class=\"metric-row\">';
    html+='<button onclick=\"calculateBetweenness()\" class=\"metric-btn btn-centrality\">ğŸ“ Centralidad</button>';
    html+='<div id=\"centralityResult\" class=\"metric-result result-centrality\"><em>Click para recalcular</em></div>';
    html+='</div><br>';
    html+='<button onclick=\"compareMetrics()\" class=\"metric-btn btn-compare\">ğŸ“Š COMPARAR MÃ‰TRICAS</button>';
    html+='<div id=\"comparisonResult\" style=\"margin-top:10px;\"></div>';
    warningText.html(html);
    updateGraph();
}
function applyEdgePerturbation(){
    if(fused||clustered||kanonActive||communityActive||clusteringPreservingActive||spectralActive)return;
    perturbActive=true;
    const epsilon=2.5;
    const p_real=Math.exp(epsilon)/(1+Math.exp(epsilon));
    const p_false=1/(1+Math.exp(epsilon));
    console.log('ğŸ”€ APLICANDO PERTURBACIÃ“N CON DIFFERENTIAL PRIVACY');
    console.log('ğŸ”€ Epsilon: '+epsilon);
    console.log('ğŸ”€ Probabilidad mantener arista existente: '+p_real.toFixed(4));
    console.log('ğŸ”€ Probabilidad aÃ±adir arista inexistente: '+p_false.toFixed(4));
    const existingEdges=new Set();
    originalLinks.forEach(l=>{
        const s=l.source.id||l.source;
        const t=l.target.id||l.target;
        const key=[s,t].sort().join('-');
        existingEdges.add(key);
    });
    const newLinks=[];
    let edgesAdded=0;
    let edgesRemoved=0;
    for(let i=0;i<nodes.length;i++){
        for(let j=i+1;j<nodes.length;j++){
            const nodeA=nodes[i].id;
            const nodeB=nodes[j].id;
            const key=[nodeA,nodeB].sort().join('-');
            const edgeExists=existingEdges.has(key);
            if(edgeExists){
                if(Math.random()<p_real){
                    newLinks.push({source:nodeA,target:nodeB});
                }else{
                    edgesRemoved++;
                }
            }else{
                if(Math.random()<p_false){
                    newLinks.push({source:nodeA,target:nodeB,perturbed:true});
                    edgesAdded++;
                }
            }
        }
    }
    links=newLinks;
    nodes.forEach(n=>{
        const degree=links.filter(l=>(l.source.id||l.source)===n.id||(l.target.id||l.target)===n.id).length;
        n.perturbDegree=degree;
    });
    console.log('âœ“ Aristas aÃ±adidas: '+edgesAdded);
    console.log('âœ“ Aristas eliminadas: '+edgesRemoved);
    console.log('âœ“ Total aristas en grafo protegido: '+links.length);
    warningBox.classed('protected',false).classed('anonymous',false).classed('kanon',false).classed('automorph',true);
    warningTitle.html('ğŸ”€ DIFFERENTIAL PRIVACY APLICADA (Îµ='+epsilon+')');
    warningText.html('ğŸ”€ <strong>RANDOMIZED RESPONSE MECHANISM</strong><br><br>ğŸ”€ Epsilon (Îµ): '+epsilon+'<br>ğŸ”€ P(mantener arista): '+p_real.toFixed(3)+'<br>ğŸ”€ P(aÃ±adir arista): '+p_false.toFixed(3)+'<br><br>ğŸ“Š <strong>Resultado:</strong><br>ğŸ”€ '+edgesAdded+' aristas aÃ±adidas<br>ğŸ”€ '+edgesRemoved+' aristas eliminadas<br>ğŸ”€ Total: '+links.length+' aristas<br><br><strong style="color:#27ae60">âœ“ Privacidad diferencial garantizada</strong>');
    perturbBtn.classed('active',true).attr('disabled','disabled');
    clusterBtn.attr('disabled','disabled');
    communityBtn.attr('disabled','disabled');
    clusteringBtn.attr('disabled','disabled');
    kanonBtn.attr('disabled','disabled');
    spectralBtn.attr('disabled','disabled');
    updateGraph();
}
function applyKAnonymity(){
    if(fused||clustered||perturbActive||communityActive||clusteringPreservingActive||spectralActive)return;
    kanonActive=true;
    const k=3;
    const newLinks=[];
    let iterations=0;
    const maxIterations=100;
    while(iterations<maxIterations){
        const degreeMap={};
        nodes.forEach(n=>{const degree=links.filter(l=>(l.source.id||l.source)===n.id||(l.target.id||l.target)===n.id).length;n.degree=degree;if(!degreeMap[degree])degreeMap[degree]=[];degreeMap[degree].push(n);});
        const rareDegrees=Object.keys(degreeMap).filter(deg=>degreeMap[deg].length<k);
        if(rareDegrees.length===0)break;
        let modified=false;
        for(const deg of rareDegrees){
            const nodesWithDeg=degreeMap[deg];
            const targetDegrees=Object.keys(degreeMap).map(d=>parseInt(d)).sort((a,b)=>Math.abs(degreeMap[b].length-k)-Math.abs(degreeMap[a].length-k));
            for(const node of nodesWithDeg){
                let bestTarget=null;
                for(const targetDeg of targetDegrees){
                    if(targetDeg===parseInt(deg))continue;
                    const candidates=degreeMap[targetDeg].filter(other=>other.id!==node.id&&!links.some(l=>((l.source.id||l.source)===node.id&&(l.target.id||l.target)===other.id)||((l.source.id||l.source)===other.id&&(l.target.id||l.target)===node.id)));
                    if(candidates.length>0){
                        bestTarget=candidates[0];
                        break;
                    }
                }
                if(bestTarget){
                    newLinks.push({source:node.id,target:bestTarget.id,added:true});
                    links.push({source:node.id,target:bestTarget.id,added:true});
                    modified=true;
                    break;
                }
            }
            if(modified)break;
        }
        if(!modified)break;
        iterations++;
    }
    const finalDegreeMap={};
    nodes.forEach(n=>{const degree=links.filter(l=>(l.source.id||l.source)===n.id||(l.target.id||l.target)===n.id).length;n.degree=degree;if(!finalDegreeMap[degree])finalDegreeMap[degree]=[];finalDegreeMap[degree].push(n);});
    const degreeGroups=Object.keys(finalDegreeMap).sort((a,b)=>parseInt(a)-parseInt(b));
    const colorMapping={};
    degreeGroups.forEach((deg,idx)=>{colorMapping[deg]=idx%8;});
    nodes.forEach(n=>{n.degreeGroup=colorMapping[n.degree];n.degreeCount=finalDegreeMap[n.degree].length;});
    warningBox.classed('protected',false).classed('anonymous',false).classed('kanon',true).classed('automorph',false);
    warningTitle.html('ğŸŸ£ K-ANONIMIDAD APLICADA (k=3)');
    let statsText='';
    const allSatisfy=degreeGroups.every(deg=>finalDegreeMap[deg].length>=k);
    degreeGroups.forEach(deg=>{const count=finalDegreeMap[deg].length;const status=count>=k?'âœ“':'âš ';statsText+=status+' Grado '+deg+': '+count+' nodos<br>';});
    warningText.html('ğŸŸ£ Aristas aÃ±adidas (lÃ­neas moradas)<br>ğŸŸ£ Cada grado compartido por â‰¥3 nodos<br>ğŸŸ£ '+newLinks.length+' conexiones aÃ±adidas<br><br><strong>DistribuciÃ³n final:</strong><br>'+statsText+(allSatisfy?'<br><strong style="color:#27ae60">âœ“ K-anonimidad satisfecha</strong>':'<br><strong style="color:#e74c3c">âš  Puede necesitar mÃ¡s aristas</strong>'));
    kanonBtn.classed('active',true).attr('disabled','disabled');
    clusterBtn.attr('disabled','disabled');
    communityBtn.attr('disabled','disabled');
    clusteringBtn.attr('disabled','disabled');
    perturbBtn.attr('disabled','disabled');
    updateGraph();
}
function toggleClusters(){
    if(fused||kanonActive||perturbActive||communityActive||clusteringPreservingActive||spectralActive)return;
    clustered=!clustered;
    if(clustered){
        node.transition().duration(1000).attr('fill',d=>colorScale(d.ciudad));
        clusterLabels.transition().duration(1000).style('opacity',1);
        simulation.force('charge',d3.forceManyBody().strength(-120));
        warningBox.classed('protected',true).classed('kanon',false).classed('automorph',false);
        warningTitle.html('ğŸ™ï¸ PROTECCIÃ“N MEJORADA');
        warningText.html('ğŸ™ï¸ Agrupados por ciudad<br>ğŸ™ï¸ Identidades individuales menos visibles<br>ğŸ™ï¸ Clusters visuales por ciudad<br>ğŸ™ï¸ Dificulta identificaciÃ³n especÃ­fica<br><br><strong>4 Ciudades<br>30 personas agrupadas</strong>');
        clusterBtn.classed('active',true).html('ğŸ‘¤ Vista Individual').attr('disabled','disabled');
        communityBtn.attr('disabled','disabled');
        clusteringBtn.attr('disabled','disabled');
        kanonBtn.attr('disabled','disabled');
        perturbBtn.attr('disabled','disabled');
        spectralBtn.attr('disabled','disabled');
        fusionTimeout=setTimeout(fusionNodes,5000);
    }else{
        if(fusionTimeout){clearTimeout(fusionTimeout);fusionTimeout=null;}
        node.transition().duration(1000).attr('fill','#3498db');
        clusterLabels.transition().duration(1000).style('opacity',0);
        simulation.force('charge',d3.forceManyBody().strength(-250));
        warningBox.classed('protected',false).classed('anonymous',false).classed('kanon',false).classed('automorph',false);
        warningTitle.html('âš ï¸ RIESGO DE PRIVACIDAD');
        warningText.html('âŒ Todos los nodos son identificables<br>âŒ Nombres, edades y profesiones visibles<br>âŒ Relaciones personales expuestas<br>âŒ Grados Ãºnicos permiten identificaciÃ³n<br><br><strong>30 personas identificables<br>43 conexiones visibles</strong>');
        clusterBtn.classed('active',false).html('ğŸ™ï¸ Agrupar por Ciudades').attr('disabled',null);
        communityBtn.attr('disabled',null);
        clusteringBtn.attr('disabled',null);
        kanonBtn.attr('disabled',null);
        perturbBtn.attr('disabled',null);
    }
    simulation.alpha(1).restart();
}
function fusionNodes(){
    if(fused)return;
    fused=true;
    const cityGroups={};
    originalNodes.forEach(n=>{if(!cityGroups[n.ciudad])cityGroups[n.ciudad]=[];cityGroups[n.ciudad].push(n);});
    nodes=Object.keys(cityGroups).map(ciudad=>{const people=cityGroups[ciudad];const avgAge=people.reduce((sum,p)=>sum+p.edad,0)/people.length;const professions=people.map(p=>p.profesion);const memberIds=people.map(p=>p.id);const cityConnections={Barcelona:0,Madrid:0,Valencia:0,Sevilla:0};originalLinks.forEach(l=>{const sourceId=typeof l.source==='string'?l.source:l.source.id;const targetId=typeof l.target==='string'?l.target:l.target.id;const sourceCiudad=originalNodes.find(n=>n.id===sourceId).ciudad;const targetCiudad=originalNodes.find(n=>n.id===targetId).ciudad;if(sourceCiudad===ciudad&&targetCiudad!==ciudad){cityConnections[targetCiudad]++;}else if(targetCiudad===ciudad&&sourceCiudad!==ciudad){cityConnections[sourceCiudad]++;}});const totalConnections=Object.values(cityConnections).reduce((a,b)=>a+b,0);return{id:ciudad,ciudad:ciudad,isSupernode:true,count:people.length,avgAge:avgAge,professions:professions,members:memberIds,cityConnections:cityConnections,connections:totalConnections};});
    const cityConnections=new Set();
    originalLinks.forEach(l=>{const sourceCiudad=originalNodes.find(n=>n.id===l.source||n.id===l.source.id).ciudad;const targetCiudad=originalNodes.find(n=>n.id===l.target||n.id===l.target.id).ciudad;if(sourceCiudad!==targetCiudad){const key=[sourceCiudad,targetCiudad].sort().join('-');cityConnections.add(key);}});
    links=Array.from(cityConnections).map(key=>{const[c1,c2]=key.split('-');return{source:c1,target:c2};});
    clusterLabels.transition().duration(1000).style('opacity',0);
    simulation.force('charge',d3.forceManyBody().strength(-300));
    simulation.force('collision',d3.forceCollide().radius(60));
    simulation.force('link').distance(200);
    warningBox.classed('protected',false).classed('kanon',false).classed('automorph',false).classed('anonymous',true);
    warningTitle.html('ğŸ”’ MÃXIMA PROTECCIÃ“N');
    warningText.html('ğŸ”’ Solo ciudades visibles<br>ğŸ”’ '+links.length+' conexiones entre ciudades<br>ğŸ”’ Identidades completamente anonimizadas<br>ğŸ”’ Solo datos agregados disponibles<br><br><strong>4 Supernodos<br>'+originalNodes.length+' personas protegidas</strong>');
    clusterBtn.html('ğŸ™ï¸ Supernodos Activos');
    updateGraph();
}
function resetSimulation(){
    if(fusionTimeout){clearTimeout(fusionTimeout);fusionTimeout=null;}
    if(fused||kanonActive||perturbActive||communityActive||clusteringPreservingActive||spectralActive){
        fused=false;
        clustered=false;
        kanonActive=false;
        perturbActive=false;
        communityActive=false;
        clusteringPreservingActive=false;
        spectralActive=false;
        communities=[];
        nodes=JSON.parse(JSON.stringify(originalNodes));
        links=JSON.parse(JSON.stringify(originalLinks));
        simulation.force('charge',d3.forceManyBody().strength(-250));
        simulation.force('collision',d3.forceCollide().radius(35));
        simulation.force('link').distance(90);
        clusterLabels.transition().duration(1000).style('opacity',0);
        warningBox.classed('anonymous',false).classed('protected',false).classed('kanon',false).classed('automorph',false);
        warningTitle.html('âš ï¸ RIESGO DE PRIVACIDAD');
        warningText.html('âŒ Todos los nodos son identificables<br>âŒ Nombres, edades y profesiones visibles<br>âŒ Relaciones personales expuestas<br>âŒ Grados Ãºnicos permiten identificaciÃ³n<br><br><strong>30 personas identificables<br>43 conexiones visibles</strong>');
        clusterBtn.classed('active',false).html('ğŸ™ï¸ Agrupar por Ciudades').attr('disabled',null);
        communityBtn.classed('active',false).attr('disabled',null);
        clusteringBtn.classed('active',false).attr('disabled',null);
        spectralBtn.classed('active',false).attr('disabled',null);
        kanonBtn.classed('active',false).attr('disabled',null);
        perturbBtn.classed('active',false).attr('disabled',null);
        updateGraph();
    }else{
        simulation.alpha(1).restart();
        svg.transition().duration(750).call(zoom.transform,d3.zoomIdentity);
    }
}
function pauseSimulation(){if(isPaused){simulation.alphaTarget(0).restart();isPaused=false;}else{simulation.stop();isPaused=true;}}
    </script>
</body>
</html>
